---
title: "Netflix ELT Pipeline End to End"
---



```{r}
library(reticulate) # r package that talks to python 
use_condaenv("base", required = TRUE) # using my conda environment base
py_config() # configuring it
```

```{python}
import pandas as pd
import os
import seaborn as sb
from matplotlib import pyplot as plt
import numpy as np
```

### Donwload the Raw CSV data here 
[Download Raw CSV](https://github.com/Sohail-44/Netflix_ELT_E2E/blob/main/EDA_Cleaning/netflix_titles.csv)


### Basic EDA 
```{python}
os.getcwd()
df_netflix = pd.read_csv("../../data/raw/netflix_titles.csv") # was in src/ica, so had to come up two directories
```



```{python}
df_netflix.head()
```

```{python}
df_netflix.shape
```

```{python}
df_netflix.info()
```

```{python}
df_netflix[df_netflix.show_id=='s5023'] # seeing the title for a particular particular id not showing other foreign characters
```
```{python}
# checking the maximum length of title -- to put as char in SQL
max(df_netflix.title.str.len()) # 104
```

```{python}
# seeing total number of missing values
df_netflix.isna().sum() # a lot of missing values in director, cast and country  
```
```{python}
# similar checking for rating 
max(df_netflix.rating.str.len()) # 8
# similarly checking for duration 
max(df_netflix.duration.str.len()) # 10
```

```{python}
# lets access some columns to understand more our data and also about user preferencences 
df_netflix['type']
```
```{python}
# I can only see Movie and TV Show in the type -- types of entertainment media on Netflix 
# Lets do a simple count using value counts method
df_netflix['type'].value_counts()
```

```{python}
# Interesting info from value counts -- people are preferring Movie compared to TV Show
# Lets graph it and then do some percentage analysis
sb.barplot(
    x=df_netflix['type'].value_counts().index,
    y=df_netflix['type'].value_counts().values
)
plt.show()
```
```{python}
# Percentage analysis 
Movie_pref = 6131
TV_Show = 2676
Total_Content = Movie_pref + TV_Show

MoviePercent = Movie_pref * 100/ Total_Content
TvShow_Percent = TV_Show * 100/ Total_Content

print(MoviePercent) # 69.61507891449983 ~ 70%
print(TvShow_Percent) # 30.38492108550017 ~ 30%
```
```{python}
# Visualizing Entertainment preference based on percentage analysis 
Entertainment_Type = [MoviePercent, TvShow_Percent]
Labels = ["% who prefer Movies", "% who prefer TV Shows"]

sb.barplot(
    x=Labels,
    y=Entertainment_Type,
    palette=sb.color_palette("Blues", as_cmap=True)([v/max(Entertainment_Type) for v in Entertainment_Type])
)

plt.title("Entertainment Type Preferred")
plt.ylabel("Percentage")
plt.ylim(0, 100)
plt.show()
```
```{python}
# Interesting this is showing how many films each director has directed 
df_netflix['director'].value_counts() # altogether 4528 directors

# lets do this : 1. lets see how many directors who have director 5 or more movies  
Top_directors = df_netflix['director'].value_counts()>=5
```
```{python}
Top_directors.value_counts()
# Wow so basically Only 92 out of 4528  Directors who have directed in 5 or more movies -- most of the directors are amateur 

four_or_less_m_directors = 4436
five_or_more_m_directors = 92
Total_directors = 4528

four_or_less_percent = 4436*100/4528
five_or_more_percent = 92*100/4528
```
```{python}
# % of Directors who directed 4 or less movies 
four_or_less_percent
# % of Directors who directed 5 or more movies 
five_or_more_percent
```
```{python}
# Figuring out top countries 
df_netflix['country'].value_counts().head(5) # Wow US, India, UK, Japan and South Korea top five countries producing
# netflix shows 
```
```{python}
# top five countries producers visulaization

plt.figure()  # starting fresh figure not to overlap
sb.barplot(x=df_netflix['country'].value_counts().head(5).index,
           y=df_netflix['country'].value_counts().head(5).values)
plt.title("Top 5 Countries")
plt.show()

```
```{python}
# lets make a filter of movies title and its description 
df_netflix[['title', 'description']]
```
```{python}
# lets try to basically make a dictionary where key is title name and value is its description
title_desc_dict = {"df_netflix['title']" : "df_netflix['description']"}
print(title_desc_dict['df_netflix[\'title\']'])
```

#### Data Cleaning, transformation and Analysis done in PostgreSQL ( Just displaying code here as text, for more info about database connection visit my github repo Netflix ELT E2E)

eval: false

# ----------------- Data Cleaning --------------------------------------- 

CREATE TABLE IF NOT EXISTS Netflix_RawData 
(	show_id		varchar(10) primary key,
	"type"		text,
	title		varchar(150),
	director	text, 
	"cast"		text,
	country		text,
	date_added	date,
	release_year int, 
	rating		varchar(15),
	duration	varchar(20),
	listed_in	text,
	description	text
)

select * from Netflix_RawData;
select * from Netflix_RawData order by title

-- checking if other non-english characters are showing up or not
select * from Netflix_RawData
where show_id = 's5023'  -- Amazing the korean characters are showing! 

-- checking for duplicates : >1
select show_id, COUNT(*)
from Netflix_RawData
group by show_id
having COUNT(*)>1 --  Show's no duplicates 

-- Just checking : Removing the duplicates using ctid to uniquely identify each row 
Delete from Netflix_RawData
where ctid not in (select min (ctid)
from Netflix_RawData
group by show_id
) -- show's 0 deleted which means no duplicates and I can safely make my show_id char

-- dropped the table and then created again to add the primary key 

-- checking for duplicates in the title
select * from Netflix_RawData
where title in (
select title
from Netflix_RawData
group by title
having COUNT(*)>1 
) -- shows no duplicates 

-- Since we have many values for single column it hinders our data analyzing abilities such as in listed-in we
-- we have international TV Show, TV dramas, TV Thrillers and this is the case for many columns we can split this

select show_id, trim(director_part) as director
from Netflix_RawData,
lateral unnest(string_to_array(director, ',')) AS director_part; -- splitting on the comma

-- inserting the new director table in Netflix_RawData
select show_id, trim (director_part) as director
into netflix_directors -- creating a new table named netflix_directors and inserting data splitted from directors there 
from  Netflix_RawData,
lateral unnest(string_to_array(director, ',')) AS director_part; 

select * from netflix_directors -- proper table created 

-- lets basically seperate cast, listed_in and country as well and create new table and directly insert 
select show_id,trim (cast_part) as single_cast_member
intp netflix_cast
from Netflix_RawData,
lateral unnest(string_to_array("cast", ',')) AS cast_part;

select * from netflix_cast

select show_id,Trim(listed_in_part) as genre
into  netflix_genre
from Netflix_RawData,
lateral unnest(string_to_array(listed_in, ',')) as listed_in_part

select * from netflix_genre

Select show_id,Trim(country_part) as  single_country
Into netflix_country
from Netflix_RawData,
lateral unnest(string_to_array(country, ',')) as country_part

select * from netflix_country

--- After running the isna() method in Jupyter we have lots of null values in director cast and country
-- For us populating country is very important 

select show_id, country
from Netflix_RawData
where country is null -- 831 rows are null 

select show_id, director
from Netflix_RawData 
where director is null -- 2634 rows are null 

select * from netflix_country where show_id = 's1001' -- if its null, its basically not showing

-- We need to somehow populate these null values : lets check for a specific director

select * from netflix_RawData where director = 'Ahishor Solomon'  --- See one country is Null and other India
-- So most probably based on probablity it might be India as he is working with Indian directors 

-- lets get a combination of director, country to see how many other countries has  each director directed  

select director, single_country	
from netflix_country nc 
inner join netflix_directors nd on nc.show_id = nd.show_id -- telling sql to look for rows which have same id in both nc and nd 
group by director, single_country
-- shows how one director can direct in different countries as well example Aaron Sorkin, Aaron, woodley etc
-- and we will basically assumme that for this dierctor if there's any country that's null that probably one
-- of the country he has already directed in can be give, based on probality 

--- Pouplating the null values of country based on these probablities and map to director in our raw data
insert into netflix_country -- inserting these values in netflix_country table 
select show_id, m.single_country
from Netflix_RawData nr
inner join (select director, single_country	
from netflix_country nc 
inner join netflix_directors nd on nc.show_id = nd.show_id  
group by director, single_country
) m on nr.director = m.director
where nr.country is null

select * from netflix_country -- awesome populated null values 

--------------- Populating duration null values--------------

select * from Netflix_Rawdata 
where duration is null  -- see some glitch with data where duration is null and its values are in rating, so lets populate duration with rating wherever null


select *,
case 
when duration is null then rating else  duration  -- if else of sql started with the case 
end as  duration_or_rating
from Netflix_RawData; -- populated 

select show_id, duration
from Netflix_Rawdata -- confirmed population replacing null values 

--- As per our Pandas EDA, date added was also null so lets see what we can do about it
select show_id, date_added
from Netflix_RawData
where date_added is null -- only around 10 rows are null, so we can leave it instead of basically adding default values


-- Creating our Final clean table --

with cte as (
select *,
row_number() over (partition by title, type order by show_id) as rn
from Netflix_RawData
)
select show_id,"type", title, cast (date_added as date) as date_added, release_year, rating, duration,
description 
into Netflix_cleaned
from cte

select * from Netflix_cleaned --- whernever we need other columns such as country, cast, director we can basically join our table

----------------------------DATA Analysis ----------------------------------------------------------

-- Answeing important analysis question and solving it with SQL query :
-- For each directors how many movies and shows they created in seperate columns 

select nd.director,
count (distinct case when n.type = 'Movie' then n.show_id end) as no_of_movies,
count (distinct case when n.type = 'TV Show' then n.show_id end) as no_of_tvshow
from Netflix_cleaned n
inner join netflix_directors nd on n.show_id = nd.show_id
group by nd.director
having count ( distinct n.type)>1 

- done got a table with director names and no.of movies and tv shows they have directed seperately

-- Which country has produced highest number of comedy movies ?

select nc.single_country, count(distinct ng.show_id) as no_of_movies
from netflix_genre ng 
inner join netflix_country nc on ng.show_id = nc.show_id 
inner join netflix_cleaned n on ng.show_id = n.show_id
where ng.genre = 'Comedies' and n.type = 'Movie'
group by nc.single_country
order by no_of_movies desc-- Got US as having the highest no.of comedy movies on top of the table
limit 1 -- postgre_sql syntax for getting the top 1


-- For each year, which director has maximum number of movies released 


with cte as (
select nd.director, extract(year from n.date_added) as date_year, count( n.show_id) as no_of_movies -- postgre sql syntax extract
from Netflix_Cleaned n 
inner join netflix_directors nd on n.show_id = nd.show_id
where type = 'Movie'
group by nd.director, extract(year from n.date_added) 
), 
cte2 as (
select *, 
row_number () over (partition by date_year order by no_of_movies desc, director ) as rn 
from cte 
)

select * from cte2 where rn=1 -- we got it from 2008 to 2021 

-- What's the avg duration of movies for each genre 

select ng.genre, floor(avg(cast(replace(n.duration, ' min', '') as int))) as avg_duration
from netflix_cleaned n
inner join netflix_genre ng on n.show_id = ng.show_id
where n.type = 'Movie' 
and n.duration ~ '^[0-9]+ min$'
group by ng.genre; -- yes we got it 

-- Find the list of directors who have created horror and comedy movies both and display director names along with no. of horror and comedy movies 


select nd.director, 
count(distinct case when ng.genre = 'Comedies' then n.show_id end) as no_of_comedy,
count(distinct case when ng.genre = 'Horror Movies' then n.show_id end) as no_of_horror
from netflix_cleaned n
inner join netflix_genre ng on n.show_id = ng.show_id
inner join netflix_directors nd on n.show_id = nd.show_id
where n.type = 'Movie' and ng.genre in ('Comedies', 'Horror Movies')
group by nd.director
having count(distinct ng.genre) = 2; -- done 






